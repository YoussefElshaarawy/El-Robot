<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Tilt Depth Parallax â€“ Minimal Starter</title>
<style>
  :root{
    --max-tilt: 12deg;         /* visual rotation clamp */
    --max-shift: 30px;         /* XY parallax clamp */
    --z1: 80px; --z2: 40px; --z3: 0px; --z4: -30px; /* layer depths */
  }
  /* Reduce motion: tone down effect amplitudes */
  @media (prefers-reduced-motion: reduce) {
    :root{ --max-tilt: 4deg; --max-shift: 10px; --z1: 30px; --z2: 15px; --z3: 0; --z4: 0; }
  }

  html, body {
    height: 100%;
    margin: 0;
    background: radial-gradient(1200px 800px at 70% 20%, #0f1216, #07090c 60%, #05070a);
    color: #e8eef5;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
  }

  .wrap {
    position: fixed; inset: 0;
    display: grid; place-items: center;
    padding: max(12px, env(safe-area-inset-top)) max(12px, env(safe-area-inset-right))
             max(24px, env(safe-area-inset-bottom)) max(12px, env(safe-area-inset-left));
  }

  .scene {
    width: min(92vw, 520px);
    height: min(62vh, 560px);
    perspective: 900px;
    perspective-origin: 50% 45%;
  }

  .card {
    position: relative;
    width: 100%; height: 100%;
    transform-style: preserve-3d;
    border-radius: 24px;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 20px 50px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.06);
    overflow: hidden;
    will-change: transform;
  }

  .layer {
    position: absolute; inset: 0;
    transform-style: preserve-3d;
    display: grid; place-items: center;
    pointer-events: none;
  }

  .bg {
    background:
      radial-gradient(180px 120px at 15% 20%, rgba(0,200,255,0.25), transparent 60%),
      radial-gradient(220px 200px at 85% 80%, rgba(120,70,255,0.25), transparent 60%),
      linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
    filter: saturate(1.1);
  }

  .grid {
    background-image:
      linear-gradient(transparent 31px, rgba(255,255,255,0.05) 32px),
      linear-gradient(90deg, transparent 31px, rgba(255,255,255,0.05) 32px);
    background-size: 32px 32px;
    mask-image: radial-gradient(100% 70% at 50% 50%, #000, transparent 85%);
  }

  .orb {
    width: 210px; height: 210px; border-radius: 999px;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.95), rgba(180,220,255,0.5) 40%, rgba(0,0,0,0) 70%),
                radial-gradient(circle at 70% 70%, rgba(120,180,255,0.35), rgba(0,0,0,0) 60%);
    box-shadow: 0 30px 60px rgba(60,130,255,0.35);
  }

  .title {
    font-weight: 700;
    letter-spacing: 0.2px;
    text-align: center;
    line-height: 1.2;
    text-shadow: 0 2px 10px rgba(0,0,0,0.4);
  }
  .title h1 { font-size: clamp(22px, 4.2vw, 34px); margin: 0 18px; }
  .title p { font-size: clamp(14px, 2.6vw, 16px); margin: 8px 20px 0; opacity: 0.85; }

  .hud {
    position: absolute; left: 12px; right: 12px; bottom: 12px;
    display: flex; gap: 10px; align-items: center; justify-content: space-between;
    opacity: 0.9;
  }
  .btn {
    appearance: none; border: 0; border-radius: 14px;
    padding: 12px 16px; font-weight: 600;
    background: rgba(255,255,255,0.1);
    color: #eaf3ff;
    backdrop-filter: blur(8px);
  }
  .btn:active { transform: translateY(1px); }
  .small { font-size: 12px; opacity: 0.8; }

  .chip {
    padding: 8px 10px; border-radius: 12px; background: rgba(255,255,255,0.08);
    font-size: 12px;
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="scene">
    <div id="card" class="card">
      <!-- deepest background -->
      <div class="layer bg" style="transform: translateZ(var(--z4));"></div>
      <!-- grid just above bg -->
      <div class="layer grid" style="transform: translateZ(var(--z3));"></div>
      <!-- orb in front -->
      <div class="layer" style="transform: translateZ(var(--z2));">
        <div class="orb"></div>
      </div>
      <!-- title at the very front -->
      <div class="layer" style="transform: translateZ(var(--z1));">
        <div class="title">
          <h1>iPhone Tilt Depth</h1>
          <p>Move your phone to peek around the scene.</p>
        </div>
      </div>

      <!-- HUD -->
      <div class="hud">
        <button id="enableBtn" class="btn">Enable Motion</button>
        <div style="display:flex; gap:8px; align-items:center;">
          <span class="chip" id="status">Idle</span>
          <span class="small">Sensitivity</span>
          <input id="sens" type="range" min="0.2" max="2.0" step="0.1" value="1" />
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const card = document.getElementById('card');
  const statusEl = document.getElementById('status');
  const enableBtn = document.getElementById('enableBtn');
  const sensEl = document.getElementById('sens');

  // Internal state
  let targetX = 0, targetY = 0;   // desired parallax (pixels)
  let targetRX = 0, targetRY = 0; // desired rotation (deg)
  let x = 0, y = 0, rx = 0, ry = 0; // smoothed state
  let smoothing = 0.12;            // 0..1 (higher = snappier)
  let sensitivity = parseFloat(sensEl.value); // user knob
  let hasMotion = false;

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

  // Apply transforms on each frame
  function render() {
    // Ease towards target
    x += (targetX - x) * smoothing;
    y += (targetY - y) * smoothing;
    rx += (targetRX - rx) * smoothing;
    ry += (targetRY - ry) * smoothing;

    const maxShift = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-shift'));
    const maxTilt = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-tilt'));

    const sx = clamp(x, -maxShift, maxShift);
    const sy = clamp(y, -maxShift, maxShift);
    const rxa = clamp(rx, -parseFloat(maxTilt), parseFloat(maxTilt));
    const rya = clamp(ry, -parseFloat(maxTilt), parseFloat(maxTilt));

    card.style.transform =
      `translate3d(${sx}px, ${sy}px, 0) rotateX(${rxa}) rotateY(${rya})`;

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // Map device orientation (beta: front/back, gamma: left/right) to targets
  function onOrientation(e) {
    // Some devices provide null initially
    if (typeof e.beta !== 'number' || typeof e.gamma !== 'number') return;

    // Normalised tilt in range roughly -1..1
    const nx = clamp(e.gamma / 45, -1, 1); // left/right
    const ny = clamp(e.beta  / 45, -1, 1); // front/back

    // Parallax shift (pixels)
    const baseShift = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-shift'));
    targetX = nx * baseShift * sensitivity;
    targetY = ny * baseShift * sensitivity * -1; // invert Y for natural feel

    // Subtle rotations to enhance depth
    const baseTilt = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-tilt'));
    targetRY = nx * baseTilt * sensitivity;       // yaw
    targetRX = ny * baseTilt * sensitivity * -1;  // pitch
  }

  // Mouse fallback (desktop demo / Safari without permission)
  function onMouse(e) {
    const rect = card.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    const nx = clamp((e.clientX - cx) / (rect.width / 2), -1, 1);
    const ny = clamp((e.clientY - cy) / (rect.height / 2), -1, 1);

    const baseShift = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-shift'));
    const baseTilt = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-tilt'));
    targetX = nx * baseShift;
    targetY = -ny * baseShift;
    targetRY = nx * baseTilt;
    targetRX = -ny * baseTilt;
  }

  // Permission flow for iOS Safari
  async function enableMotion() {
    try {
      // iOS 13+ requires explicit permission after a user gesture
      const needsPerm =
        typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function';

      if (needsPerm) {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== 'granted') {
          statusEl.textContent = 'Motion blocked';
          return;
        }
      }
      // Start listening
      window.addEventListener('deviceorientation', onOrientation, { passive: true });
      hasMotion = true;
      statusEl.textContent = 'Motion on';
      enableBtn.style.display = 'none';
    } catch (err) {
      statusEl.textContent = 'Error enabling motion';
      console.error(err);
    }
  }

  // Wire up UI
  enableBtn.addEventListener('click', enableMotion);
  sensEl.addEventListener('input', () => {
    sensitivity = parseFloat(sensEl.value);
  });

  // Desktop fallback
  window.addEventListener('mousemove', (e) => {
    if (!hasMotion) onMouse(e);
  }, { passive: true });

  // Orientation change handling (keeps feel consistent)
  window.addEventListener('orientationchange', () => {
    // Recentre smoothly
    targetX = targetY = targetRX = targetRY = 0;
  }, { passive: true });
})();
</script>
</body>
</html>
