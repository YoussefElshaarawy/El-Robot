<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Tilt Depth — iOS-Safe Starter</title>
<style>
  :root{ --max-tilt: 12deg; --max-shift: 28px; --z1: 80px; --z2: 40px; --z3: 0; --z4: -30px; }
  @media (prefers-reduced-motion: reduce){ :root{ --max-tilt: 4deg; --max-shift: 10px; --z1: 24px; --z2: 12px; --z3: 0; --z4: 0; } }
  html,body{height:100%;margin:0;background:#07090c;color:#eaf2ff;font-family:-apple-system, system-ui, Segoe UI, Inter, Roboto, Arial}
  .wrap{position:fixed;inset:0;display:grid;place-items:center;padding:env(safe-area-inset-top) env(safe-area-inset-right) calc(16px + env(safe-area-inset-bottom)) env(safe-area-inset-left)}
  .scene{width:min(92vw,520px);height:min(64vh,560px);perspective:900px;perspective-origin:50% 45%}
  .card{position:relative;width:100%;height:100%;transform-style:preserve-3d;border-radius:24px;overflow:hidden;
    background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.1);box-shadow:0 20px 50px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06)}
  .layer{position:absolute;inset:0;transform-style:preserve-3d;display:grid;place-items:center;pointer-events:none}
  .bg{background:
    radial-gradient(180px 120px at 15% 20%, rgba(0,200,255,.25), transparent 60%),
    radial-gradient(220px 200px at 85% 80%, rgba(120,70,255,.25), transparent 60%),
    linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0))}
  .grid{background-image:
      linear-gradient(transparent 31px, rgba(255,255,255,.06) 32px),
      linear-gradient(90deg, transparent 31px, rgba(255,255,255,.06) 32px);
    background-size:32px 32px;mask-image:radial-gradient(100% 70% at 50% 50%, #000, transparent 85%)}
  .orb{width:210px;height:210px;border-radius:999px;
    background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(180,220,255,.5) 40%, rgba(0,0,0,0) 70%),
               radial-gradient(circle at 70% 70%, rgba(120,180,255,.35), rgba(0,0,0,0) 60%);
    box-shadow:0 30px 60px rgba(60,130,255,.35)}
  .title{font-weight:700;text-align:center;line-height:1.2;text-shadow:0 2px 10px rgba(0,0,0,.4)}
  .title h1{font-size:clamp(22px,4.2vw,34px);margin:0 18px}
  .title p{font-size:clamp(14px,2.6vw,16px);margin:8px 20px 0;opacity:.85}
  .hud{position:absolute;left:12px;right:12px;bottom:12px;display:flex;gap:10px;align-items:center;justify-content:space-between}
  .btn{appearance:none;border:0;border-radius:14px;padding:12px 16px;font-weight:600;background:rgba(255,255,255,.12);color:#eaf3ff;backdrop-filter:blur(8px)}
  .chip{padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.09);font-size:12px}
  .diag{position:fixed;left:10px;top:10px;background:rgba(0,0,0,.45);backdrop-filter:blur(6px);padding:8px 10px;border-radius:10px;font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, monospace;white-space:pre}
</style>
</head>
<body>
<div class="wrap">
  <div class="scene">
    <div id="card" class="card">
      <div class="layer bg"   style="transform: translateZ(var(--z4));"></div>
      <div class="layer grid" style="transform: translateZ(var(--z3));"></div>
      <div class="layer"      style="transform: translateZ(var(--z2));"><div class="orb"></div></div>
      <div class="layer"      style="transform: translateZ(var(--z1));">
        <div class="title"><h1>Tilt Depth</h1><p>Tilt to peek around the scene.</p></div>
      </div>
      <div class="hud" style="pointer-events:auto">
        <button id="enableBtn" class="btn">Enable Motion</button>
        <div style="display:flex;gap:8px;align-items:center">
          <span class="chip" id="status">Idle</span>
          <span style="font-size:12px;opacity:.8">Sensitivity</span>
          <input id="sens" type="range" min="0.2" max="2.0" step="0.1" value="1" />
        </div>
      </div>
    </div>
  </div>
</div>
<div id="diag" class="diag">secure:false
perm:—
events: ori=0 mot=0
beta:— gamma:—
</div>

<script>
(() => {
  const card = document.getElementById('card');
  const statusEl = document.getElementById('status');
  const enableBtn = document.getElementById('enableBtn');
  const sensEl = document.getElementById('sens');
  const diag = document.getElementById('diag');

  // State
  let targetX=0,targetY=0,targetRX=0,targetRY=0;
  let x=0,y=0,rx=0,ry=0;
  let smoothing=0.12;
  let sensitivity=parseFloat(sensEl.value);
  let haveOri=false, haveMot=false, granted=false;

  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

  function updateDiag(extra={}){
    const d = {
      secure: window.isSecureContext,
      perm: granted ? 'granted' : '—',
      events: `ori=${haveOri?1:0} mot=${haveMot?1:0}`,
      ...extra
    };
    diag.textContent = `secure:${d.secure}\nperm:${d.perm}\nevents: ${d.events}\n${d.more||''}`;
  }
  updateDiag();

  // Animation loop
  function render(){
    x += (targetX - x) * smoothing;
    y += (targetY - y) * smoothing;
    rx += (targetRX - rx) * smoothing;
    ry += (targetRY - ry) * smoothing;

    const styles = getComputedStyle(document.documentElement);
    const maxShift = parseFloat(styles.getPropertyValue('--max-shift'));
    const maxTilt  = parseFloat(styles.getPropertyValue('--max-tilt'));

    const sx = clamp(x, -maxShift, maxShift);
    const sy = clamp(y, -maxShift, maxShift);
    const rxa = clamp(rx, -parseFloat(maxTilt), parseFloat(maxTilt));
    const rya = clamp(ry, -parseFloat(maxTilt), parseFloat(maxTilt));

    card.style.transform = `translate3d(${sx}px, ${sy}px, 0) rotateX(${rxa}) rotateY(${rya})`;
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // Orientation (primary path)
  function onOrientation(e){
    haveOri = true;
    if (typeof e.beta !== 'number' || typeof e.gamma !== 'number') return;
    const nx = clamp(e.gamma/45, -1, 1);
    const ny = clamp(e.beta/45,  -1, 1);

    const styles = getComputedStyle(document.documentElement);
    const baseShift = parseFloat(styles.getPropertyValue('--max-shift'));
    const baseTilt  = parseFloat(styles.getPropertyValue('--max-tilt'));

    targetX = nx * baseShift * sensitivity;
    targetY = -ny * baseShift * sensitivity;
    targetRY = nx * baseTilt * sensitivity;
    targetRX = -ny * baseTilt * sensitivity;

    updateDiag({ more:`beta:${e.beta?.toFixed(1)} gamma:${e.gamma?.toFixed(1)}` });
  }

  // Motion fallback (derives tilt from gravity vector)
  function onMotion(e){
    haveMot = true;
    const ag = e.accelerationIncludingGravity;
    if (!ag) return;
    const RAD = 180/Math.PI;
    // NOTE: axis mapping varies; this mapping works well in iOS portrait.
    const beta  = Math.atan2(ag.y, ag.z) * RAD; // front/back
    const gamma = Math.atan2(ag.x, ag.z) * RAD; // left/right
    const nx = clamp(gamma/45, -1, 1);
    const ny = clamp(beta/45,  -1, 1);

    const styles = getComputedStyle(document.documentElement);
    const baseShift = parseFloat(styles.getPropertyValue('--max-shift'));
    const baseTilt  = parseFloat(styles.getPropertyValue('--max-tilt'));

    targetX = nx * baseShift * sensitivity;
    targetY = -ny * baseShift * sensitivity;
    targetRY = nx * baseTilt * sensitivity;
    targetRX = -ny * baseTilt * sensitivity;

    updateDiag({ more:`beta~:${beta.toFixed(1)} gamma~:${gamma.toFixed(1)}` });
  }

  async function enableMotion(){
    // Hard fail: not HTTPS / not secure context
    if (!window.isSecureContext) {
      statusEl.textContent = 'Use HTTPS (required)';
      updateDiag();
      return;
    }

    try {
      // Request both permissions if available (iOS 13+)
      const needsOri = typeof DeviceOrientationEvent !== 'undefined'
        && typeof DeviceOrientationEvent.requestPermission === 'function';
      const needsMot = typeof DeviceMotionEvent !== 'undefined'
        && typeof DeviceMotionEvent.requestPermission === 'function';

      let ok = true;
      if (needsOri) ok = (await DeviceOrientationEvent.requestPermission()) === 'granted' && ok;
      if (needsMot) ok = (await DeviceMotionEvent.requestPermission()) === 'granted' && ok;

      granted = ok || (!needsOri && !needsMot); // other platforms
      if (!granted) {
        statusEl.textContent = 'Permission denied';
        updateDiag();
        return;
      }

      // Listeners
      window.addEventListener('deviceorientation', onOrientation, { passive:true });
      window.addEventListener('devicemotion',      onMotion,       { passive:true });

      statusEl.textContent = 'Motion on';
      enableBtn.style.display = 'none';
      updateDiag();
    } catch (err){
      statusEl.textContent = 'Error enabling motion';
      console.error(err);
      updateDiag({ more:String(err) });
    }
  }

  // Wire UI
  enableBtn.addEventListener('click', enableMotion);
  sensEl.addEventListener('input', () => { sensitivity = parseFloat(sensEl.value); });

  // Mouse fallback for desktop demo
  window.addEventListener('mousemove', (e) => {
    if (granted) return; // only before motion is on
    const r = card.getBoundingClientRect();
    const nx = clamp((e.clientX - (r.left + r.width/2)) / (r.width/2), -1, 1);
    const ny = clamp((e.clientY - (r.top + r.height/2)) / (r.height/2), -1, 1);
    const styles = getComputedStyle(document.documentElement);
    const baseShift = parseFloat(styles.getPropertyValue('--max-shift'));
    const baseTilt  = parseFloat(styles.getPropertyValue('--max-tilt'));
    targetX = nx * baseShift; targetY = -ny * baseShift;
    targetRY = nx * baseTilt; targetRX = -ny * baseTilt;
  }, { passive:true });

  window.addEventListener('orientationchange', () => {
    targetX = targetY = targetRX = targetRY = 0; // recenter
  }, { passive:true });
})();
</script>
</body>
</html>
